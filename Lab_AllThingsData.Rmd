---
title: 'Data Processing, Descriptives, Visualization, and More in R/RStudio'
author: "Created by Kayla Sansevere for PSY207: Advanced Statistics I Lab"
date: "Friday, October 17, 2025"
output:
  html_document:
    toc: yes
  word_document:
    toc: yes
---


```{r setup, include=FALSE}
## include = F: prevent code and results from appearing in knitted file;
## still runs the code in the chunk, and results can be used by other chunks

## Default options for code blocks when knitting
knitr::opts_chunk$set(echo = FALSE, ## echo = F: prevent code but not results from knit
                      warning = FALSE, ## warning = F: prevent warnings generated by code 
                      message = FALSE) ## message = F: prevent messages generated by code 

#Clear workspace to avoid any interference/conflicts in environment
rm(list=ls(all=TRUE))

#### Load in libraries #### 
## Install and load packages using librarian
if (!'librarian' %in% installed.packages()) install.packages('librarian')
librarian::shelf(tidytuesdayR, tidyverse, psych, ggthemes, gridExtra, RColorBrewer, apaTables, wordcloud2)
## Package information:
#tidytuesdayR: Data sets
#tidyverse: Data manipulation & visualization
#psych: Descriptive statistics
#ggthemes: Themes for data viz
#gridExtra: Arranging graphs
#RColorBrewer: Colors for data viz
#apaTables: Correlation table
#wordcloud2: Word clouds

## Check info including version, packages, etc
sessionInfo()

## Set seed for reproducibility
set.seed(207)
```

# Taylor Swift Data

[Click this
hyperlink](https://github.com/rfordatascience/tidytuesday/blob/master/data/2023/2023-10-17/readme.md#taylor_all_songscsv)
to view the full data dictionary for the Taylor Swift data set. For our
convenience, here are the variables that are most important for this lab
activity:

-   **danceability** ($y$): Spotify danceability score, ranges from $0$
    (least danceable) to $100$ (most danceable)

-   **valence** ($x_1$): Spotify valence score, ranges from $0$ (low
    valence, sounds more negative... sad, depressed, angry) to $100$
    (high valence, sounds more positive... happy, cheerful, euphoric)

-   **tempo** ($x_2$): Overall estimated track tempo (i.e., speed or
    pace of a given piece and derives directly from the average beat
    duration) in beats per minute (BPM)

-   **era** ($x_3$): Era of the album release, denoted with $3$ levels:
    early ($2006-2012$), mid ($2013-2019$), and late ($2020-2022$)
    
```{r swift import and tidying, include = FALSE}
#### Import data ####
# See all available data from tidy tuesday
# tt_available()

# Import Taylor Swift data
# This will import 3 lists of data
swift <- tt_load("2023-10-17")

# Save each data frame from the list
swift_album_songs <- swift$taylor_album_songs
swift_all_songs <- swift$taylor_all_songs
swift_albums <- swift$taylor_albums

#### Tidy data ####
# check data structure
str(swift_all_songs)

## change track_release to date format
swift_all_songs$track_release <- as.Date(swift_all_songs$track_release)

# extract the year and convert to numeric format
swift_all_songs$track_release <- as.numeric(format(swift_all_songs$track_release, "%Y"))

# create new col to simplify release date into broader categories
swift_all_songs <- swift_all_songs %>%
    mutate(era = case_when(
        track_release <= 2012 ~ 'early',
        track_release >= 2020  ~ 'late',
        track_release = 2013 | 2014 | 2015 | 2016 | 2017 | 2018 | 2019 ~ 'mid'))

# recode era to factor
swift_all_songs$era <- factor(swift_all_songs$era,levels = c("early","mid","late"))

# recode some cols for easier interpretation
swift_all_songs$danceability <- swift_all_songs$danceability*100
swift_all_songs$valence <- swift_all_songs$valence*100 

# remove missing values
swift_all_songs <- swift_all_songs %>%
    drop_na(danceability,valence,tempo,era)

# recheck data structure
str(swift_all_songs)

# View the head of the data
head(swift_all_songs)

# View the tail of the data
tail(swift_all_songs)
```

\

1.  First, it's important we run some preliminary analysis to better understand our data. Interpret the appropriate descriptive statistics (e.g., $M$, $SD$, $skewness$, $kurtosis$) 
for danceability, valence, and tempo.
What do you notice about these descriptive statistics across eras?

```{r swift descriptives}
## fetch descriptives for just our subset of continuous variables
swift_sub <- swift_all_songs[c('danceability', 'valence', 'tempo')]
cat("Danceability, valence, and tempo descriptives:")
psych::describe(swift_sub)
# psych::describe(swift_all_songs) ## uncomment to see all descriptives


## describe select continuous variables by level of categorical variable
cat("Danceability, valence, and tempo descriptives by era:")
psych::describe(danceability + valence + tempo ~ era, data = swift_all_songs)
```

\

2. Let's now look at the distribution of our continuous variables and see 
if they're normally distributed.

```{r swift histograms}
# Set up a side-by-side layout
par(mfrow=c(1, 3)) # 1 graph along 3 spots
# The par() function allows to set parameters to the plot.
# The mfrow() parameter allows to split the screen in several panels.

# Create side-by-side histograms using base R
# Danceability
hist(swift_all_songs$danceability, # specify the variable
     main="Danceability Distribution", # title
     xlab="Danceability Score", # x axis label
     ylab="Frequency", # y axis label
     col="lavender", # histogram bar color
     xlim=c(0, 100)) # x axis limits

# Valence
hist(swift_all_songs$valence, main="Valence Distribution", 
         xlab="Valence Score", ylab="Frequency", 
         col="midnightblue", xlim=c(0, 100))

# Tempo
hist(swift_all_songs$tempo, main="Tempo Distribution", 
     xlab="Tempo (BPM)", ylab="Frequency", col="pink")

# Here's a color cheat sheet:
# https://www.nceas.ucsb.edu/sites/default/files/2020-04/colorPaletteCheatsheet.pdf
```
\

3. Create box plots of our continuous variables (danceability, valence, tempo) 
to visually summarize the distribution of data, showing its center (median), 
spread (variability), and skewness at a glance. 
Do you notice any potential outliers? [Here's how to interpret box plots if you need a refresher.](https://leansigmacorporation.com/box-plot-with-minitab/)

```{r swift boxplots}
# Danceability
p1 <- ggplot(swift_all_songs, aes(y = danceability)) + ## specify data
  geom_boxplot(fill = "lavender") + ## specify graph type and fill color
  ## set axis titles
  labs(title = "Danceability boxplot", 
       y = "Danceability Score", 
       x = NULL) +
  ## set theme specs
  theme_minimal() +
  theme(panel.grid = element_blank()) ## remove gridlines

# Valence
p2 <- ggplot(swift_all_songs, aes(y = valence)) +
  geom_boxplot(fill = "midnightblue") +
  labs(title = "Valence boxplot", y = "Valence Score", x = NULL) +
  theme_minimal() +
  theme(panel.grid = element_blank())

# Tempo
p3 <- ggplot(swift_all_songs, aes(y = tempo)) +
  geom_boxplot(fill = "pink") +
  labs(title = "Tempo boxplot", y = "Tempo (BPM)", x = NULL) +
  theme_minimal() +
  theme(panel.grid = element_blank())

# Arrange plots side by side
gridExtra::grid.arrange(p1, p2, p3, ncol = 3)
```
\

4. Box plots are especially useful for comparing distributions across multiple groups.
Graph danceability, valence, and tempo by era. What do you notice?
\
```{r swift more boxplots}
# Graph danceability by era
ggplot(data = swift_all_songs, # specify the data frame
       aes(x = era, # x axis
           y = danceability, # y axis
           fill = era)) + # color to be filled in
  geom_boxplot() + # specify box plot
  # set labels
  labs(title = "Danceability by Era", # title
         x = "Era", # x axis label
         y = "Danceability") + # y axis label
  scale_fill_brewer(palette = "Accent") + # set color palette
  theme_minimal() + # set theme
  theme(legend.position = "none", # no legend
        panel.grid = element_blank(), # remove gridlines
        plot.title = element_text(size = 14, face = "bold")) # type face

# View all color options
# Run this in your console for a better view
# RColorBrewer::display.brewer.all()

# Graph valence by era
ggplot(data = swift_all_songs, # specify the data frame
       aes(x = era, # x axis
           y = valence, # y axis
           fill = era)) + # color to be filled in
  geom_boxplot() + # specify box plot
  # set labels
  labs(title = "Valence by Era", # title
         x = "Era", # x axis label
         y = "Valence") + # y axis label
  scale_fill_brewer(palette = "Set3") + # set color palette
  theme_minimal() + # set theme
  theme(legend.position = "none", # no legend
        panel.grid = element_blank(), # remove gridlines
        plot.title = element_text(size = 14, face = "bold")) # type face

# Graph tempo by era
ggplot(data = swift_all_songs, # specify the data frame
       aes(x = era, # x axis
           y = tempo, # y axis
           fill = era)) + # color to be filled in
  geom_boxplot() + # specify box plot
  # set labels
  labs(title = "Tempo by Era", # title
         x = "Era", # x axis label
         y = "Tempo") + # y axis label
  scale_fill_brewer(palette = "Pastel2") + # set color palette
  theme_minimal() + # set theme
  theme(legend.position = "none", # no legend
        panel.grid = element_blank(), # remove gridlines
        plot.title = element_text(size = 14, face = "bold")) # type face
```

\

5. Let's graph some scatter plots and examine the relationships between our continuous variables. We'll also examine scatter plots by looking at era. 
What trends can we describe in terms of direction (i.e., positive, negative, or none), form (i.e., linear, curved, or no pattern), and strength (i.e., weak, moderate, or strong)?
```{r swift scatterplots}
# Danceability x valence scatterplot
ggplot(data = swift_all_songs, # specify the data source
       aes(x=valence, # x axis 
           y=danceability)) + # y axis
  geom_point(size=2, # point size
               color="lightblue") + # point color
  labs(title = "Scatterplot of Valence and Danceability", # title
         x = "Valence", # x axis label
         y = "Danceability") + # y axis label
  # line of best fit
  geom_smooth(method = "lm", #  specifies a linear model for the line of best fit
              se = FALSE, # removes the default confidence interval band around the line
              color = "grey") + # line color
  theme_minimal() +  # theme
  theme(panel.grid = element_blank()) # remove gridlines

# Danceability x valence scatterplot by era
ggplot(data = swift_all_songs, # specify the data source
       aes(x=valence, # x axis 
           y=danceability, # y axis
           alpha = era)) + # alpha of different factor levels
  geom_point(size=2, # point size
               color="lightblue") + # point color
  labs(title = "Scatterplot of Valence and Danceability by Era", # title
         x = "Valence", # x axis label
         y = "Danceability") + # y axis label
  theme_minimal() +  # theme
  theme(panel.grid = element_blank()) # remove gridlines

# Danceability x tempo scatterplot
ggplot(data = swift_all_songs, # specify the data source
       aes(x=tempo, # x axis 
           y=danceability)) + # y axis
  geom_point(size=2, # point size
               color="darkorchid") + # point color
  labs(title = "Scatterplot of Tempo and Danceability", # title
         x = "Tempo", # x axis label
         y = "Danceability") + # y axis label
  # line of best fit
  geom_smooth(method = "lm", #  specifies a linear model for the line of best fit
              se = FALSE, # removes the default confidence interval band around the line
              color = "black") + # line color
  theme_minimal() +  # theme
  theme(panel.grid = element_blank()) # remove gridlines

# Danceability x tempo scatterplot by era
ggplot(data = swift_all_songs, # specify the data source
       aes(x=tempo, # x axis 
           y=danceability, # y axis
           alpha = era)) + # alpha of different factor levels
  geom_point(size=2, # point size
               color="darkorchid") + # point color
  labs(title = "Scatterplot of Tempo and Danceability by Era", # title
         x = "Tempo", # x axis label
         y = "Danceability") + # y axis label
  theme_minimal() +  # theme
  theme(panel.grid = element_blank()) # remove gridlines

# Valence x tempo scatterplot
ggplot(data = swift_all_songs, # specify the data source
       aes(x=valence, # x axis 
           y=tempo)) + # y axis
  geom_point(size=2, # point size
               color="red") + # point color
  labs(title = "Scatterplot of Valence and Tempo", # title
         x = "Valence", # x axis label
         y = "Tempo") + # y axis label
  # line of best fit
  geom_smooth(method = "lm", #  specifies a linear model for the line of best fit
              se = FALSE, # removes the default confidence interval band around the line
              color = "black") + # line color
  theme_minimal() +  # theme
  theme(panel.grid = element_blank()) # remove gridlines

# Valence x tempo scatterplot by era
ggplot(data = swift_all_songs, # specify the data source
       aes(x=valence, # x axis 
           y=tempo, # y axis
           alpha = era)) + # alpha of different factor levels
  geom_point(size=2, # point size
               color="red") + # point color
  labs(title = "Scatterplot of Valence and Tempo by Era", # title
         x = "Valence", # x axis label
         y = "Tempo") + # y axis label
  theme_minimal() +  # theme
  theme(panel.grid = element_blank()) # remove gridlines
```

\

6. Let's create a correlation table of danceability, valence, and tempo to supplement the conclusions that we observed in our scatter plots.
```{r swift correlation}
table1 <- apaTables::apa.cor.table(data=swift_sub,
                                   table.number=1,filename = "taylor_correlations.doc")
print(table1)
```

\

# Cocoa Data 

We have some other data this week which comes from [Flavors of Cacao](http://flavorsofcacao.com/chocolate_database.html), which contains about chocolate! Let's explore our data.
```{r cocoa import and tidying, include = FALSE}
#### Import data ####
choc <- tt_load("2022-01-18")
## Data source:
## https://github.com/rfordatascience/tidytuesday/tree/master/data/2022/2022-01-18

# Overwrite a data frame from the list
choc <- choc$chocolate

#### Tidy data ####
## See if our data looks how it should
head(choc) ##view the first 5 instances of the df
#View(choc) ##view entire df

## View data structure
str(choc)
## cols to be factor: ref, company_manufacturer, company_location, 
## review_date, country_of_bean_origin, cocoa_percent

## Change select cols to factors
choc <- choc %>%
    mutate(across(c(ref, company_manufacturer, company_location,
                    review_date, country_of_bean_origin),
                  as.factor))

## check str again
str(choc)

## let's see how many levels for cocoa percentage that we have
table(choc$cocoa_percent)

## Subset by cocoa percent levels
choc_sub <- choc[choc$cocoa_percent 
                 %in% c('65%', '70%', '75%', '80%'), ]

## However, there is unequal N across our factor levels!
table(choc_sub$cocoa_percent)

## subset so each group has equal N across levels
choc_sub <- choc_sub %>% 
    group_by(cocoa_percent) %>% 
    sample_n(89) # we chose 89 because that's our minimum value

## check levels again
table(choc_sub$cocoa_percent)
```

We are interested if **cocoa percentage** ($65$%, $70$%, $75$%, $80$%) **impacts chocolate bar ratings**. Cocoa percentage refers to sum of the cocoa bean and any added cocoa butter content; a higher percentage (e.g., $80$%) indicates less cocoa butter (e.g., $20$%). Our sample $N$ = `r nrow(choc_sub)`.

1.  It's important we run some preliminary analysis to better understand our data. Interpret the appropriate descriptive statistics (e.g., $M$, $SD$, $skewness$, $kurtosis$) for chocolate bar ratings across cocoa percentage groups.

```{r cocoa descriptives}
## get descriptive stats overall
cat("Descriptives of chocolate bar rating:")
psych::describe(x = choc_sub$rating)

## get descriptive stats by cocoa level
cat("Descriptives of chocolate bar rating as a product of cocoa percentage:")
psych::describe(rating ~ cocoa_percent, data = choc_sub)
## Here's another way you could do this:
# rating_desc <- choc_sub %>% ##create new df
#   group_by(cocoa_percent) %>% ##group by predictor
#   summarise(n = length(cocoa_percent), ##group level
#             mean = round(mean(rating),2), ##mean
#             sd = round(sd(rating),2), ##sd
#             skew = round(moments::skewness(rating),2), ##skewness
#             kurtosis = round(moments::kurtosis(rating),2)) ##kurtosis
# 
# print(rating_desc) ##print results
```

\

2. Let's look at a histogram to supplement our conclusions from the descriptive statistics and check if chocolate bar ratings are normally distributed.
```{r cocoa histogram}
# Create a histogram using base R
hist(choc_sub$rating, # specify the variable
     main="Chocolate Bar Rating Distribution", # title
     xlab="Chocolate Bar Rating", # x axis label
     ylab="Frequency", # y axis label
     col="brown", # histogram bar color
     xlim=c(1, 4)) # x axis limits
```

\

3. Now let's examine a box plot of chocolate bar ratings by cocoa percentage.
What trends do you notice?

```{r cocoa boxplot}
# Graph bar rating by cocoa percentage
ggplot(data = choc_sub, # specify the data frame
       aes(x = cocoa_percent, # x axis
           y = rating, # y axis
           fill = cocoa_percent)) + # color to be filled in
  geom_boxplot() + # specify box plot
  # set labels
  labs(title = "Chocolate Bar Ratings by Cocoa Percentage", # title
         x = "Cocoa Percentage", # x axis label
         y = "Chocolate Bar Rating") + # y axis label
  scale_fill_brewer(palette = "BrBG") + # set color palette
  theme_minimal() + # set theme
  theme(legend.position = "none",
        panel.grid = element_blank(), # remove gridlines
        plot.title = element_text(size = 14, face = "bold")) # type face

# View all color options
# Run this in your console for a better view
# RColorBrewer::display.brewer.all()
```
\

4. What words are used most commonly used to describe our sample of chocolate?
```{r cocoa wordcloud}
## Prepare the data
# example: choc_sub$most_memorable_characteristics is a character vector
x <- choc_sub$most_memorable_characteristics

# tidy tokenization: split on commas, trim, tolower, drop NA/empty
tokens <- tibble(text = x) %>%
  filter(!is.na(text)) %>%
  mutate(text = as.character(text)) %>% # ensure text is character
  separate_rows(text, sep = ",") %>% # split comma-separated items into rows
  mutate(token = str_trim(text), # trim whitespace
         token = str_to_lower(token)) %>% # lowercase
  filter(token != "")

# optional: remove tokens you consider noise
noise <- c("wtf", "n/a", "na", "none") # expand as needed
tokens <- tokens %>% filter(!token %in% noise)

# frequency table of words
freq <- tokens %>% count(token, sort = TRUE)

## basic interactive wordcloud
wordcloud2::wordcloud2(freq, size = 1) # size adjusts scaling
```
